#include "main.hpp"
#define CONFIG_DEBUG_PPM_ASTAR 1




static u8 asciitable[128*16]={
0x00,0x00,0x3E,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x00
0x00,0x00,0x0C,0x1C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x00,0x00,0x00,0x00,	//0x01
0x00,0x00,0x3E,0x63,0x03,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00,	//0x02
0x00,0x00,0x3E,0x63,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x03
0x00,0x00,0x06,0x0E,0x1E,0x36,0x66,0x66,0x7F,0x06,0x06,0x0F,0x00,0x00,0x00,0x00,	//0x04
0x00,0x00,0x7F,0x60,0x60,0x60,0x7E,0x03,0x03,0x63,0x73,0x3E,0x00,0x00,0x00,0x00,	//0x05
0x00,0x00,0x1C,0x30,0x60,0x60,0x7E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x06
0x00,0x00,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x00,0x00,0x00,0x00,	//0x07
0x00,0x00,0x3E,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x08
0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x3C,0x00,0x00,0x00,0x00,	//0x09
0x00,0x00,0x08,0x1C,0x36,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x00,0x00,0x00,0x00,	//0x0a
0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x33,0x33,0x33,0x33,0x7E,0x00,0x00,0x00,0x00,	//0x0b
0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x60,0x60,0x61,0x33,0x1E,0x00,0x00,0x00,0x00,	//0x0c
0x00,0x00,0x7C,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x7C,0x00,0x00,0x00,0x00,	//0x0d
0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00,	//0x0e
0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,	//0x0f
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x10
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x11
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x12
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x13
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x14
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x15
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x16
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x17
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x18
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x19
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x1a
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x1b
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x1c
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x1d
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x1e
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,	//0x1f
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x20
0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,	//0x21 !
0x00,0x63,0x63,0x63,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x22 "
0x00,0x00,0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00,	//0x23 #
0x0C,0x0C,0x3E,0x63,0x61,0x60,0x3E,0x03,0x03,0x43,0x63,0x3E,0x0C,0x0C,0x00,0x00,	//0x24 $
0x00,0x00,0x00,0x00,0x00,0x61,0x63,0x06,0x0C,0x18,0x33,0x63,0x00,0x00,0x00,0x00,	//0x25 %
0x00,0x00,0x00,0x1C,0x36,0x36,0x1C,0x3B,0x6E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,	//0x26 &
0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x27 '
0x00,0x00,0x0C,0x18,0x18,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x00,0x00,0x00,0x00,	//0x28 (
0x00,0x00,0x18,0x0C,0x0C,0x06,0x06,0x06,0x06,0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,	//0x29 )
0x00,0x00,0x00,0x00,0x42,0x66,0x3C,0xFF,0x3C,0x66,0x42,0x00,0x00,0x00,0x00,0x00,	//0x2a *
0x00,0x00,0x00,0x00,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,	//0x2b +
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,	//0x2c ,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x2d -
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,	//0x2e .
0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,	//0x2f /
0x00,0x00,0x3E,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x30 0
0x00,0x00,0x0C,0x1C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x00,0x00,0x00,0x00,	//0x31 1
0x00,0x00,0x3E,0x63,0x03,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00,	//0x32 2
0x00,0x00,0x3E,0x63,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x33 3
0x00,0x00,0x06,0x0E,0x1E,0x36,0x66,0x66,0x7F,0x06,0x06,0x0F,0x00,0x00,0x00,0x00,	//0x34 4
0x00,0x00,0x7F,0x60,0x60,0x60,0x7E,0x03,0x03,0x63,0x73,0x3E,0x00,0x00,0x00,0x00,	//0x35 5
0x00,0x00,0x1C,0x30,0x60,0x60,0x7E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x36 6
0x00,0x00,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x00,0x00,0x00,0x00,	//0x37 7
0x00,0x00,0x3E,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x38 8
0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x3C,0x00,0x00,0x00,0x00,	//0x39 9
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,	//0x3a :
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,	//0x3b //
0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,	//0x3c <
0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,	//0x3d =
0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,	//0x3e >
0x00,0x00,0x3E,0x63,0x63,0x06,0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00,	//0x3f ?
0x00,0x00,0x3E,0x63,0x63,0x6F,0x6B,0x6B,0x6E,0x60,0x60,0x3E,0x00,0x00,0x00,0x00,	//0x40 @
0x00,0x00,0x08,0x1C,0x36,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x00,0x00,0x00,0x00,	//0x41 A
0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x33,0x33,0x33,0x33,0x7E,0x00,0x00,0x00,0x00,	//0x42 B
0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x60,0x60,0x61,0x33,0x1E,0x00,0x00,0x00,0x00,	//0x43 C
0x00,0x00,0x7C,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x7C,0x00,0x00,0x00,0x00,	//0x44 D
0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00,	//0x45 E
0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,	//0x46 F
0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x6F,0x63,0x63,0x37,0x1D,0x00,0x00,0x00,0x00,	//0x47 G
0x00,0x00,0x63,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00,	//0x48 H
0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,	//0x49 I
0x00,0x00,0x0F,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,	//0x4a J
0x00,0x00,0x73,0x33,0x36,0x36,0x3C,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00,	//0x4b K
0x00,0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00,	//0x4c L
0x00,0x00,0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00,	//0x4d M
0x00,0x00,0x63,0x63,0x73,0x7B,0x7F,0x6F,0x67,0x63,0x63,0x63,0x00,0x00,0x00,0x00,	//0x4e N
0x00,0x00,0x1C,0x36,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x00,0x00,0x00,0x00,	//0x4f O
0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,	//0x50 P
0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6F,0x3E,0x06,0x07,0x00,0x00,	//0x51 Q
0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00,	//0x52 R
0x00,0x00,0x3E,0x63,0x63,0x30,0x1C,0x06,0x03,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x53 S
0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,	//0x54 T
0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x55 U
0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x08,0x00,0x00,0x00,0x00,	//0x56 V
0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x36,0x00,0x00,0x00,0x00,	//0x57 W
0x00,0x00,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x3C,0x66,0xC3,0xC3,0x00,0x00,0x00,0x00,	//0x58 X
0x00,0x00,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,	//0x59 Y
0x00,0x00,0x7F,0x63,0x43,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00,	//0x5a Z
0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,	//0x5b [
0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,	//0x5c backslash
0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,	//0x5d ]
0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x5e ^
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,	//0x5f _
0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x60 `
0x00,0x00,0x00,0x00,0x00,0x3C,0x46,0x06,0x3E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,	//0x61 a
0x00,0x00,0x70,0x30,0x30,0x3C,0x36,0x33,0x33,0x33,0x33,0x6E,0x00,0x00,0x00,0x00,	//0x62 b
0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x60,0x60,0x60,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x63 c
0x00,0x00,0x0E,0x06,0x06,0x1E,0x36,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,	//0x64 d
0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x7E,0x60,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x65 e
0x00,0x00,0x1C,0x36,0x32,0x30,0x7C,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,	//0x66 f
0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,0x00,	//0x67 g
0x00,0x00,0x70,0x30,0x30,0x36,0x3B,0x33,0x33,0x33,0x33,0x73,0x00,0x00,0x00,0x00,	//0x68 h
0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,	//0x69 i
0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,	//0x6a j
0x00,0x00,0x70,0x30,0x30,0x33,0x33,0x36,0x3C,0x36,0x33,0x73,0x00,0x00,0x00,0x00,	//0x6b k
0x00,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,	//0x6c l
0x00,0x00,0x00,0x00,0x00,0x6E,0x7F,0x6B,0x6B,0x6B,0x6B,0x6B,0x00,0x00,0x00,0x00,	//0x6d m
0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x33,0x33,0x00,0x00,0x00,0x00,	//0x6e n
0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x6f o
0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x3E,0x30,0x30,0x78,0x00,0x00,	//0x70 p
0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00,0x00,	//0x71 q
0x00,0x00,0x00,0x00,0x00,0x6E,0x3B,0x33,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,	//0x72 r
0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x38,0x0E,0x03,0x63,0x3E,0x00,0x00,0x00,0x00,	//0x73 s
0x00,0x00,0x08,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x1B,0x0E,0x00,0x00,0x00,0x00,	//0x74 t
0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,	//0x75 u
0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x36,0x36,0x1C,0x1C,0x08,0x00,0x00,0x00,0x00,	//0x76 v
0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x00,0x00,0x00,0x00,	//0x77 w
0x00,0x00,0x00,0x00,0x00,0x63,0x36,0x1C,0x1C,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,	//0x78 x
0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x3F,0x03,0x06,0x3C,0x00,0x00,	//0x79 y
0x00,0x00,0x00,0x00,0x00,0x7F,0x66,0x0C,0x18,0x30,0x63,0x7F,0x00,0x00,0x00,0x00,	//0x7a z
0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,	//0x7b {
0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,	//0x7c |
0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,	//0x7d }
0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x7e ~
0x00,0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00		//0x7f DEL
};
void drawascii(u32* screen, u32 rgb, int xx, int yy, u8 ch)
{
	u8 temp;
	u8* points;
	int x,y,offset;
	int width = 1024;
	int height = 1024;
	int stride = 1024;

	if((xx<0)|(xx+8>width)|(yy<0)|(yy+16>height))return;
	if((ch<=0x20)|(ch>=0x80))ch = 0x20;
	points = asciitable + (ch<<4);

	for(y=0;y<16;y++)
	{
		temp = points[y];
		for(x=0;x<8;x++)
		{
			offset = stride*(yy+y) + xx+x;
			if((offset >= 0)&&(offset < stride*height))
			{
				if( (temp&0x80) != 0 )screen[offset] = rgb;
			}

			temp<<=1;
		}//x
	}//y
}
void drawstring(u32* win, u32 rgb, int x, int y, u8* buf, int len)
{
	int j;
	if(0 == buf)return;
	if(0 == len){
		for(;len<256;len++)if(buf[len] == 0)break;
	}
	for(j=0;j<len;j++){
		if(0 == buf[j])break;
		drawascii(win, rgb, x+j*8, y, buf[j]);
	}
}
void drawstring_atpoint(u32* win, u32 rgb, int x, int y, u8* buf, int len)
{
	int j=0;
	while(buf[j]>=' ')j++;
	drawstring(win, rgb, x-(j*8/2), y-8, buf, len);
}




void drawcolor(u8* pix, u32 rgb)
{
	int width = 1024;
	int height = 1024;
	u32* buf = (u32*)pix;
	for(int j=0;j<width*height;j++)buf[j] = rgb;
}
void drawline(u8* pix, u32 rgb, int x0, int y0, int x1, int y1)
{
	int width = 1024;
	int height = 1024;
	int stride = 1024;
	u32* buf = (u32*)pix;

	int dx,dy,sx,sy,e1,e2;
	if(x0 < x1){dx = x1-x0;sx = 1;}
	else {dx = x0-x1;sx = -1;}
	if(y0 < y1){dy = y1-y0;sy = 1;}
	else {dy = y0-y1;sy = -1;}
	if(dx > dy){e1 = dx/2;}
	else {e1 = -dy/2;}

	while(1)
	{
		if((x0 == x1)&&(y0 == y1))break;

		if((x0 >= 0)&&(x0 < width)&&(y0 >= 0)&&(y0 < height))
		{buf[(y0*stride) + x0] = rgb;}

		e2 = e1;
		if(e2 >-dx){e1 -= dy;x0 += sx;}
		if(e2 < dy){e1 += dx;y0 += sy;}
	}
}
void drawline_rect(u8* pix, u32 rgb, int x1, int y1, int x2, int y2)
{
	int width = 1024;
	int height = 1024;
	int stride = 1024;
	u32* buf = (u32*)pix;

	int x,y,n;
	int startx,endx,starty,endy;
	if(x1<x2){startx=x1;endx=x2;}
	else{startx=x2;endx=x1;}
	if(y1<y2){starty=y1;endy=y2;}
	else{starty=y2;endy=y1;}
	//logtoall("(%x,%x),(%x,%x)\n",startx,starty,endx,endy);

	for(n=0;n<1;n++)
	{
		if((starty+n >= 0) && (starty+n < height))
		{
			for(x=startx;x<endx;x++)
			{
				if(x >= width)break;
				if(x < 0)x=0;
				buf[((starty+n)*stride) + x] = rgb;
			}
		}
		if((endy-n >= 0) && (endy-n < height))
		{
			for(x=startx;x<endx;x++)
			{
				if(x > width-1)break;
				if(x < 0)x=0;
				buf[((endy-n-1)*stride) + x] = rgb;
			}
		}
		if((startx+n >= 0) && (startx+n < width))
		{
			for(y=starty;y<endy;y++)
			{
				if(y >= height)break;
				if(y < 0)y = 0;
				buf[(y*stride) + startx+n] = rgb;
			}
		}
		if((endx-n >= 0) && (endx-n < width))
		{
			for(y=starty;y<endy;y++)
			{
				if(y >= height)break;
				if(y < 0)y = 0;
				buf[(y*stride) + endx-n] = rgb;
			}
		}
	}
}
void drawsolid_rect(u8* pix, u32 rgb, int x1, int y1, int x2, int y2)
{
	//printf("%s:%d,%d,%d,%d\n",__FUNCTION__, x1,y1, x2, y2);
	int width = 1024;
	int height = 1024;
	int stride = 1024;
	u32* buf = (u32*)pix;

	int startx,endx;
	if(x1<x2){startx=x1;endx=x2;}
	else{startx=x2;endx=x1;}
	if(startx<0)startx = 0;
	if(endx>1024)endx = 1024;

	int starty,endy;
	if(y1<y2){starty=y1;endy=y2;}
	else{starty=y2;endy=y1;}
	if(starty<0)starty = 0;
	if(endy>1024)endy = 1024;

	int x,y;
	for(y=starty;y<endy;y++){
		u32* tmp = &buf[y*stride];
		for(x=startx;x<endx;x++)tmp[x] = rgb;
	}
}




u32 hsv_to_rgb(float h, float s, float v) {
	float c = v * s;
	float x = c * (1 - fabs(fmod(h / 60.0, 2) - 1));
	float m = v - c;

	float r1, g1, b1;
	if (h >= 0 && h < 60) {
		r1 = c;
		g1 = x;
		b1 = 0;
	} else if (h >= 60 && h < 120) {
		r1 = x;
		g1 = c;
		b1 = 0;
	} else if (h >= 120 && h < 180) {
		r1 = 0;
		g1 = c;
		b1 = x;
	} else if (h >= 180 && h < 240) {
		r1 = 0;
		g1 = x;
		b1 = c;
	} else if (h >= 240 && h < 300) {
		r1 = x;
		g1 = 0;
		b1 = c;
	} else {
		r1 = c;
		g1 = 0;
		b1 = x;
	}

	u32 ir = (u32)((r1 + m) * 255);
	u32 ig = (u32)((g1 + m) * 255);
	u32 ib = (u32)((b1 + m) * 255);
	return (ir<<16) | (ig<<8) | ib;
}
std::vector<u32> buildcolortable(int size, int special){
	std::vector<u32> tab;
	for(int j=0;j<size;j++){
		tab.push_back(hsv_to_rgb(360.0*j/size, 1.0, 1.0));
	}
	if(special)tab.push_back(0xffffff);
	return tab;
}
void writeppm(unsigned char* buf, int pitch, int w, int h, const char* name)
{
	printf("buf=%p,pitch=0x%x,w=%d,h=%d\n", buf, pitch, w, h);
	FILE* fp = fopen(name, "wb");

	char tmp[0x100];
	int ret = snprintf(tmp, 0x100, "P6\n%d\n%d\n255\n", w, h);
	fwrite(tmp, 1, ret, fp);

	int x,y;
	unsigned char* row;
	for(y = 0; y < h; y++) {
		row = buf + pitch*y;
		for(x = 0; x < w; x++) {
			fwrite(row+2, 1, 1, fp);
			fwrite(row+1, 1, 1, fp);
			fwrite(row+0, 1, 1, fp);
			row += 4;
		}
	}

	fclose(fp);
}




void drawchip(design* ds, position* pos, u8* pix){
	int cnt_chip = ds->_chip.size();
	float sq = sqrt(cnt_chip);
	int ce = ceil(sq);

	int ix,iy,sz;
	for(int j=0;j<cnt_chip;j++){
		ix = pos->_chip[j].x;
		iy = pos->_chip[j].y;
		sz = 1024/ce/4;
		drawline_rect(pix, 0x888888, ix-sz, iy-sz, ix+sz, iy+sz);
		printf("ix=%d,iy=%d,name=%s\n", ix, iy, (u8*)ds->_chip[j]->cname.c_str());
		drawstring_atpoint((u32*)pix, 0x888888, ix, iy, (u8*)ds->_chip[j]->cname.c_str(), 0);
	}
}
void drawfoot(design* ds, position* pos, u8* pix){
	int cnt_chip = ds->_chip.size();
	int ix,iy;
	for(int j=0;j<cnt_chip;j++){
		for(int k=0;k<pos->_chipfoot[j].size();k++){
			ix = pos->_chip[j].x + pos->_chipfoot[j][k].x;
			iy = pos->_chip[j].y + pos->_chipfoot[j][k].y;
			drawsolid_rect(pix, 0x888888, ix-3, iy-3, ix+3, iy+3);
		}
	}
}
void drawpinout(design* ds, position* pos, u8* pix){
	int cnt_po = ds->_pinout.size();
	int ix,iy;
	for(int j=0;j<cnt_po;j++){
		for(int k=0;k<pos->_out.size();k++){
			ix = pos->_out[j].x;
			iy = pos->_out[j].y;
			drawsolid_rect(pix, 0x888888, ix-3, iy-3, ix+3, iy+3);
		}
	}
}




void drawwire_chipview(position* pos, u8* pix){
	int cnt_po = pos->_out.size();
	int cnt_pi = pos->_in.size();
	int cnt_pg = pos->_pin_global.size();
	std::vector<u32> colortable = buildcolortable(cnt_po+cnt_pi+cnt_pg, 0);

	int ix,iy;
	int ox,oy;
	for(int j=0;j<pos->chipviewwire.size();j++){
		for(int k=0;k<pos->chipviewwire[j].size();k++){
			int chipid = pos->chipviewwire[j][k].chipid;
			int footid = pos->chipviewwire[j][k].footid;
			ix = pos->_chip[chipid].x + pos->_chipfoot[chipid][footid].x;
			iy = pos->_chip[chipid].y + pos->_chipfoot[chipid][footid].y;
			//
			int pinid = pos->chipviewwire[j][k].pinid;
			if(pinid < cnt_po){		//in pinout
				ox = pos->_out[pinid].x;
				oy = pos->_out[pinid].y;
			}
			else if(pinid < cnt_po+cnt_pi){		//in pinin
				ox = pos->_in[pinid-cnt_po].x;
				oy = pos->_in[pinid-cnt_po].y;
			}
			else{		//maybe power pin
				//ox = ix;
				//oy = iy-10;
				ox = pos->_pin_global[pinid-cnt_po-cnt_pi].x;
				oy = pos->_pin_global[pinid-cnt_po-cnt_pi].y;
			}
			//
			printf("%d,%d : chip%d.foot%d-pin%d : %d,%d - %d,%d\n", j,k, chipid,footid,pinid, ix, iy, ox, oy);
			drawline(pix, colortable[pinid], ix,iy, ox,oy);
		}
	}
}




void drawwire_pinview(position* pos, u8* pix){
	int cnt_po = pos->_out.size();
	int cnt_pi = pos->_in.size();
	int cnt_pg = pos->_pin_global.size();
	std::vector<u32> colortable = buildcolortable(cnt_po+cnt_pi+cnt_pg, 0);

	int ix,iy;
	int ox,oy;
	for(int j=0;j<pos->pinviewwire.size();j++){
		int pinid = j;
		if(pinid < cnt_po){		//in pinout
			ox = pos->_out[pinid].x;
			oy = pos->_out[pinid].y;
		}
		else if(pinid < cnt_po+cnt_pi){		//in pinin
			ox = pos->_in[pinid-cnt_po].x;
			oy = pos->_in[pinid-cnt_po].y;
		}
		else{		//maybe power pin
			//ox = ix;
			//oy = iy-10;
			ox = pos->_pin_global[pinid-cnt_po-cnt_pi].x;
			oy = pos->_pin_global[pinid-cnt_po-cnt_pi].y;
		}
		for(int k=0;k<pos->pinviewwire[j].size();k++){
			int chipid = pos->pinviewwire[j][k].chipid;
			int footid = pos->pinviewwire[j][k].footid;
			ix = pos->_chip[chipid].x + pos->_chipfoot[chipid][footid].x;
			iy = pos->_chip[chipid].y + pos->_chipfoot[chipid][footid].y;//
			printf("%d,%d : chip%d.foot%d-pin%d : %d,%d - %d,%d\n", j,k, chipid,footid,pinid, ix, iy, ox, oy);
			if( (pinid<cnt_po) | (pinid>=cnt_po+cnt_pi) | (k>0) ){
			drawline(pix, colortable[pinid], ix,iy, ox,oy);
			}
			ox = ix;
			oy = iy;
		}
	}
}



#define CONFIG_NOT_CONNECTED_PIXEL 16
//
#define CONFIG_DILATE_CHIP_GAP 2
#define CONFIG_DILATE_WIRE_GAP 2
//
#define MAP_VAL_EMPTY 0
#define MAP_VAL_DILATE 0x000000ff
#define MAP_VAL_DONTDILATE 0x0000ff00	//this can only change to MAP_VAL_WIRE
#define MAP_WIRE_FIRST 0xff400000
#define MAP_WIRE_FINAL (MAP_WIRE_FIRST+0xffff)
#define MAP_CHIP_FIRST 0xffc00000
#define MAP_CHIP_FINAL (MAP_CHIP_FIRST+0xffff)
void drawmap_chip(u32* map, position* pos){
	int cnt_chip = pos->_chip.size();
	float sq = sqrt(cnt_chip);
	int ce = ceil(sq);

	int ix,iy,sz;
	for(int j=0;j<cnt_chip;j++){
		ix = pos->_chip[j].x;
		iy = pos->_chip[j].y;
		sz = 1024/ce/4;
		drawline_rect((u8*)map, MAP_CHIP_FIRST+j, ix-sz, iy-sz, ix+sz, iy+sz);
	}
}
void drawmap_dontdilate(u32* map, int x, int y)
{
	for(int m=0;m<=CONFIG_NOT_CONNECTED_PIXEL;m++){
		if(y<m)break;
		map[(y-m)*1024+x] = MAP_VAL_DONTDILATE;
	}
}
void drawmap_begin(design* ds, position* pos, u32* map)
{
	drawcolor((u8*)map, 0);
	drawmap_chip((u32*)map, pos);

	//several pixels above the point dont allow dilate
	int ix,iy;
	int ox,oy;
	int cnt_po = ds->_pinout.size();
	for(int j=0;j<pos->pinviewwire.size();j++){
		int pinid = j;
		if(pinid < cnt_po){		//in pinout
			ox = pos->_out[pinid].x;
			oy = pos->_out[pinid].y;
			drawmap_dontdilate(map, ox, oy);
		}

		for(int k=0;k<pos->pinviewwire[j].size();k++){
			int chipid = pos->pinviewwire[j][k].chipid;
			int footid = pos->pinviewwire[j][k].footid;
			ix = pos->_chip[chipid].x + pos->_chipfoot[chipid][footid].x;
			iy = pos->_chip[chipid].y + pos->_chipfoot[chipid][footid].y;
			drawmap_dontdilate(map, ix, iy);
		}
	}
}
void draw_globalpin(u32* pix, position* pos){
	int po = pos->_out.size();
	int pi = pos->_in.size();
	int pg = pos->_pin_global.size();
	printf("%s: %d,%d,%d\n", __FUNCTION__, po, pi, pg);
	for(int j=po+pi;j<pos->pinviewwire.size();j++){
		for(int k=0;k<pos->pinviewwire[j].size();k++){
			int chipid = pos->pinviewwire[j][k].chipid;
			int footid = pos->pinviewwire[j][k].footid;
			int cx = pos->_chip[chipid].x;
			int cy = pos->_chip[chipid].y;
			int dx = pos->_chipfoot[chipid][footid].x;
			int dy = pos->_chipfoot[chipid][footid].y;
			int x = cx+dx;
			int y = cy+dy;
			printf("%d,%d: %d,%d\n", j,k, chipid, footid);
			drawsolid_rect((u8*)pix, 0xffffff, x-4, y-8, x+4, y);
		}
	}
}
void draw_map2pix(u32* pix, u32* map, std::vector<u32> colortable)
{
	for(int y=0;y<1024;y++){
	for(int x=0;x<1024;x++){
		int tmp = y*1024+x;
		u32 val = map[tmp];
		if( (val>=MAP_WIRE_FIRST) && (val<=MAP_WIRE_FINAL) ){
			int wireid = val - MAP_WIRE_FIRST;
			pix[tmp] = colortable[wireid];
		}
	}
	}
}


//initial value = gap between two chip
void eachchip_initradius(std::vector<int>& perchipinfo, position* pos)
{
	for(int j=0;j<pos->_chip.size();j++){
		perchipinfo.push_back(pos->_chipfoot[j].size());
	}
}
int wireid2radius(int wireid)
{
	return CONFIG_DILATE_WIRE_GAP;
}
int chipid2radius(int chipid, std::vector<int>& perchipinfo)
{
	//2, 2+1+2, 2+(1+2)*2
	int remain = perchipinfo[chipid];
	//printf("chipid=%d,remain=%d\n", chipid, remain);
	return CONFIG_DILATE_CHIP_GAP + (1+CONFIG_DILATE_CHIP_GAP)*remain;
}
void drawwire_dilate_onepixel(u32* map, int cnt, int ix, int iy)
{
	int sx = (ix < cnt) ? 0 : (ix - cnt);
	int sy = (iy < cnt) ? 0 : (iy - cnt);
	int ex = (ix+cnt>1023) ? 1023 : (ix+cnt);
	int ey = (iy+cnt>1024) ? 1023 : (iy+cnt);
	for(int y=sy;y<=ey;y++){
	for(int x=sx;x<=ex;x++){
		if(0 == map[y*1024+x]){
			map[y*1024+x] = MAP_VAL_DILATE;
		}
	}
	}
}
void drawwire_dilate(u32* map, std::vector<int>& perchipinfo){
	//clear previous dilate
	for(int y=0;y<1024;y++){
		for(int x=0;x<1024;x++){
			//printf("drawwire_dilate1: %d,%d:%x\n", x,y,map[y*1024+x]);
			if(map[y*1024+x] == MAP_VAL_DILATE)map[y*1024+x] = MAP_VAL_EMPTY;
		}
	}

	for(int y=0;y<1024;y++){
	for(int x=0;x<1024;x++){
		u32 val = map[y*1024+x];
		//printf("drawwire_dilate2: %d,%d:%x\n", x,y,val);
		if( (val >= MAP_CHIP_FIRST) && (val <= MAP_CHIP_FINAL) ){
			int chipid = val - MAP_CHIP_FIRST;
			int radius = chipid2radius(chipid, perchipinfo);
			//printf("drawwire_dilate3: %d,%d:%x,%x,%x\n", x,y,val,chipid,radius);
			drawwire_dilate_onepixel(map, radius, x, y);
		}//if
		else if( (val >= MAP_WIRE_FIRST) && (val <= MAP_WIRE_FINAL) ){
			int wireid = val - MAP_WIRE_FIRST;
			int radius = wireid2radius(wireid);
			drawwire_dilate_onepixel(map, radius, x, y);
		}//if
	}//dx
	}//dy
}




u32 astar_parent_encode(u16 x, u16 y)
{
	return 0x80008000 | (y<<16) | x;
}
int astar_parent_decode(u32* history, u16 x, u16 y, u16* parentx, u16* parenty)
{
	u32 val = history[y*1024+x];
	if((val&0x80008000) != 0x80008000)return 0;

	*parentx = val & 0x7fff;
	*parenty =(val>>16) & 0x7fff;
	return 1;
}
void astar_traceback(u32* map, u32* history, u16 x, u16 y, u32 pinid)
{
	int ret;
	u16 parentx,parenty;
	for(;;){
		//printf("%d,%d\n", x, y);
		map[(y*1024)+x] = MAP_WIRE_FIRST + pinid;

		ret = astar_parent_decode(history, x, y, &parentx, &parenty);
		if(0 == ret)break;
		if((x==parentx)&&(y==parenty))break;

		x = parentx;
		y = parenty;
	}
}




struct astar_data{
	u16 x;
	u16 y;
	//
	u16 parentx;
	u16 parenty;
	//
	int cost_to_src;
	int cost_to_dst;
	//
	int besttarget;
};
struct astar_target{
	u16 x;
	u16 y;
	short chipid;
	short pinid;
};
int astar_check(
	std::vector<astar_data>& openlist,
	std::vector<astar_target>& tarlist,
	std::vector<int>& perchip,
	u32* map,
	u32* history,
	u16 x, u16 y, u16 parentx, u16 parenty,
	int cost, u32 pinid)
{
	if(x < 0)return 0;
	if(x > 1023)return 0;
	if(y < 0)return 0;
	if(y > 1023)return 0;
	if(history[y*1024+x])return 0;

	//cond1: mark this pixel visited
	history[y*1024+x] = astar_parent_encode(parentx, parenty);
	openlist.push_back( {x, y, parentx, parenty, cost, 0} );

	//cond2: global set map
	for(auto it=tarlist.begin();it!=tarlist.end();){
		//debug
		if(abs(x-it->x) + abs(y-it->y) < 5)printf("%d,%d ? %d,%d\n", x, y, it->x, it->y);

		//
		if((x==it->x)&&(y==it->y)){
			printf("found it: %d,%d, %d,%d\n", x, y, parentx, parenty);
			int chipid = it->chipid;
			if(perchip[chipid]>0)perchip[chipid] -= 1;
			printf("found it.traceback\n");
			astar_traceback(map, history, x, y, pinid);
			printf("found it.erase\n");
			it = tarlist.erase(it);
			printf("found it.end\n");
		}
		else it++;
	}
	return 1;
}




int drawwire_astar_one(
	u32* pix, u32* map, u32* history,
	std::vector<int>& perchip, std::vector<astar_target>& tpos,
	int pinid, u32 color)
{
	for(int y=0;y<1024;y++){
	for(int x=0;x<1024;x++){
		u32* p = &map[y*1024+x];
		u32* q = &history[y*1024+x];
		if( (0==*p) | (MAP_VAL_DONTDILATE==*p) ){*q = 0;}
		else *q = 0xffffffff;		//fake it in history, means cannot access this pixel
	}
	}

	std::vector<astar_data> openlist;
	std::vector<astar_target> tarlist;
	for(int k=0;k<tpos.size();k++){
		printf("foot%d : %d,%d\n", k, tpos[k].x, tpos[k].y);

		u16 x = tpos[k].x;
		u16 y = tpos[k].y;
		short chipid = tpos[k].chipid;
		short pinid = tpos[k].pinid;

		if(0==k){
			printf("openlist += %d,%d\n", x, y);
			history[y*1024+x] = astar_parent_encode(x, y);
			openlist.push_back( {x, y, x, y, 0, 0} );
		}
		else{
			printf("tarlist += %d,%d\n", x, y);
			tarlist.push_back( {x, y, chipid, pinid} );
		}
	}


	for(int j=0;j<500000;j++){
		if(openlist.size() == 0)break;
		if(tarlist.size() == 0)break;

		int minidx = 0;
		int minval = 99999999;
		for(int p=0;p<openlist.size();p++){
			openlist[p].cost_to_dst = abs(openlist[p].x - tarlist[0].x) + abs(openlist[p].y - tarlist[0].y);
			openlist[p].besttarget = 0;
			for(int q=1;q<tarlist.size();q++){
				int cost = abs(openlist[p].x - tarlist[q].x) + abs(openlist[p].y - tarlist[q].y);
				if(openlist[p].cost_to_dst > cost){
					//printf("update cost %d\n", cost);
					openlist[p].cost_to_dst = cost;
					openlist[p].besttarget = q;
				}
			}
			//printf("round%d openlist%d: x=%d,y=%d,cost=%d+%d,besttarget=%d\n", j, p, openlist[p].x, openlist[p].y, openlist[p].cost_to_src, openlist[p].cost_to_dst, openlist[p].besttarget);
			int sum = openlist[p].cost_to_src + openlist[p].cost_to_dst;
			if(minval > sum){
				minidx = p;
				minval = sum;
			}
		}

		int mx = openlist[minidx].x;
		int my = openlist[minidx].y;
		int cost = openlist[minidx].cost_to_src;
		//printf("round%d: openlist.size=%zu,tarlist.size=%zu,minidx=%d,minval=%d,x=%d,y=%d\n", j, openlist.size(), tarlist.size(), minidx, minval, mx, my);

		//closelist.push_back(openlist[minidx]);
		openlist.erase(openlist.begin()+minidx);

		int size_old = openlist.size();
		astar_check(
			openlist, tarlist, perchip,
			map, history,
			mx  , my-1, mx, my,
			cost+1, pinid);
		astar_check(
			openlist, tarlist, perchip,
			map, history,
			mx  , my+1, mx, my,
			cost+1, pinid);
		astar_check(
			openlist, tarlist, perchip,
			map, history,
			mx+1, my  , mx, my,
			cost+1, pinid);
		astar_check(
			openlist, tarlist, perchip,
			map, history,
			mx-1, my  , mx, my,
			cost+1, pinid);
		int size_new = openlist.size();
		/*
		if(size_old == size_new){
			printf("round%d: size=%d\n", j, size_old);
		}*/
	}

	//failed foots: reach out 8 pixel
	for(int j=0;j<tarlist.size();j++){
		for(int y=0;y<8;y++){
			if(tarlist[j].y < y)break;
			pix[(tarlist[j].y - y) * 1024 + tarlist[j].x] = color;
		}
	}
	//none connected: draw source pin
	if(tpos.size()==tarlist.size()+1){
		for(int y=0;y<8;y++){
			if(tpos[0].y < y)break;
			pix[(tpos[0].y - y) * 1024 + tpos[0].x] = color;
		}
	}

#if CONFIG_DEBUG_PPM_ASTAR==1
	char name[128];
	snprintf(name, 128, "debug%x_total%zu_remain%zu_color%06x_map.ppm",
		pinid, tpos.size(), tarlist.size(), color);
	writeppm((u8*)map, 1024*4, 1024, 1024, name);
	snprintf(name, 128, "debug%x_total%zu_remain%zu_color%06x_history.ppm",
		pinid, tpos.size(), tarlist.size(), color);
	writeppm((u8*)history, 1024*4, 1024, 1024, name);
#endif
	return tarlist.size();
}
void drawwire_astar(design* ds, position* pos, u32* pix){
	int cnt_po = ds->_pinout.size();
	int cnt_pi = ds->_pinin.size();
	std::vector<u32> colortable = buildcolortable(cnt_po+cnt_pi, 1);

	u32* map = (u32*)malloc(1024*1024*4);
	drawmap_begin(ds, pos, map);

	u32* parent = (u32*)malloc(1024*1024*4);
	for(int y=0;y<1024;y++)for(int x=0;x<1024;x++)parent[y*1024+x] = 0;

	std::vector<int> perchipinfo;
	eachchip_initradius(perchipinfo, pos);

	int ix,iy;
	int ox,oy;
	std::vector<std::vector<astar_target>> perpinpos;
	for(int j=0;j<pos->pinviewwire.size();j++){
		std::vector<astar_target> one;
		if(j < cnt_po){		//in pinout
			ox = pos->_out[j].x;
			oy = pos->_out[j].y;
			one.push_back({(u16)ox, (u16)oy, -1});
		}
		else if(j < cnt_po+cnt_pi){		//in pinin
		}
		else break;

		for(int k=0;k<pos->pinviewwire[j].size();k++){
			short pinid = pos->pinviewwire[j][k].pinid;
			short chipid = pos->pinviewwire[j][k].chipid;
			short footid = pos->pinviewwire[j][k].footid;
			ix = pos->_chip[chipid].x + pos->_chipfoot[chipid][footid].x;
			iy = pos->_chip[chipid].y + pos->_chipfoot[chipid][footid].y;
			one.push_back({(u16)ix, (u16)iy, chipid, pinid});
		}
		perpinpos.push_back(one);
	}

	for(int j=0;j<perpinpos.size();j++){
		printf("index=%d,pin=%d,size=%zu{\n", j, perpinpos[j][0].pinid, perpinpos.size());

		drawwire_dilate((u32*)map, perchipinfo);
		int ret = drawwire_astar_one(
			(u32*)pix, (u32*)map, (u32*)parent,
			perchipinfo, perpinpos[j],
			j, colortable[j]);

		printf("}index=%d,ret=%d\n", j, ret);
		printf("\n\n");

		//
		//if(j>=1)break;
	}

	//convert map to pixdraw_map2pix
	draw_map2pix(pix, map, colortable);
	draw_globalpin(pix, pos);

	free(map);
}
void drawwire_astar_lesspinfirst(design* ds, position* pos, u32* pix){
	printf("build colortable\n");
	int cnt_po = ds->_pinout.size();
	int cnt_pi = ds->_pinin.size();
	std::vector<u32> colortable = buildcolortable(cnt_po+cnt_pi, 1);

	printf("build map\n");
	u32* map = (u32*)malloc(1024*1024*4);
	drawmap_begin(ds, pos, map);

	printf("build history\n");
	u32* history = (u32*)malloc(1024*1024*4);
	for(int y=0;y<1024;y++)for(int x=0;x<1024;x++)history[y*1024+x] = 0;

	printf("perchip\n");
	std::vector<int> perchipinfo;
	eachchip_initradius(perchipinfo, pos);

	printf("perpin\n");
	int ix,iy;
	int ox,oy;
	std::vector<std::vector<astar_target>> perpinpos;
	for(int j=0;j<pos->pinviewwire.size();j++){
		std::vector<astar_target> one;
		if(j < cnt_po){		//in pinout
			ox = pos->_out[j].x;
			oy = pos->_out[j].y;
			one.push_back({(u16)ox, (u16)oy, -1, -1});
		}
		else if(j < cnt_po+cnt_pi){		//in pinin
		}
		else break;

		for(int k=0;k<pos->pinviewwire[j].size();k++){
			short pinid = pos->pinviewwire[j][k].pinid;
			short chipid = pos->pinviewwire[j][k].chipid;
			short footid = pos->pinviewwire[j][k].footid;
			ix = pos->_chip[chipid].x + pos->_chipfoot[chipid][footid].x;
			iy = pos->_chip[chipid].y + pos->_chipfoot[chipid][footid].y;
			one.push_back({(u16)ix, (u16)iy, chipid, pinid});
		}

		perpinpos.push_back(one);
	}

	printf("sort\n");
	std::sort(perpinpos.begin(), perpinpos.end(), [](const std::vector<astar_target>& a, const std::vector<astar_target>& b) {
		return a.size() < b.size();
	});

	printf("go\n");
	for(int j=0;j<perpinpos.size();j++){
		int pinid = -1;
		if(perpinpos[j].size()>1)pinid = perpinpos[j][1].pinid;
		printf("index=%d,pin=%d,size=%zu{\n", j, pinid, perpinpos[j].size());

		drawwire_dilate((u32*)map, perchipinfo);
		int ret = drawwire_astar_one(
			(u32*)pix, (u32*)map, (u32*)history,
			perchipinfo, perpinpos[j],
			j, colortable[j]);

		printf("}index=%d,ret=%d\n", j, ret);
		printf("\n\n");
	}

	printf("map2pix\n");
	draw_map2pix(pix, map, colortable);
	draw_globalpin(pix, pos);

	printf("free\n");
	free(history);
	free(map);
}




void draw_onlychip(design* ds, position* pos, u8* pix){
	printf("%s{\n",__FUNCTION__);
	drawcolor(pix, 0);

	drawchip(ds, pos, pix);

	writeppm(pix, 1024*4, 1024, 1024, "onlychip.ppm");
	printf("}%s\n",__FUNCTION__);
}
void draw_onlyfoot(design* ds, position* pos, u8* pix){
	printf("%s{\n",__FUNCTION__);
	drawcolor(pix, 0);

	drawfoot(ds, pos, pix);

	writeppm(pix, 1024*4, 1024, 1024, "onlyfoot.ppm");
	printf("}%s\n",__FUNCTION__);
}
void draw_onlypinout(design* ds, position* pos, u8* pix){
	printf("%s{\n",__FUNCTION__);
	drawcolor(pix, 0);

	drawpinout(ds, pos, pix);

	writeppm(pix, 1024*4, 1024, 1024, "onlypinout.ppm");
	printf("}%s\n",__FUNCTION__);
}
void draw_chipview(design* ds, position* pos, u8* pix){
	printf("%s{\n",__FUNCTION__);
	drawcolor(pix, 0);

	drawchip(ds, pos, pix);
	drawfoot(ds, pos, pix);
	drawpinout(ds, pos, pix);

	drawwire_chipview(pos, pix);

	writeppm(pix, 1024*4, 1024, 1024, "wire_chipview.ppm");
	printf("}%s\n",__FUNCTION__);
}
void draw_pinview(design* ds, position* pos, u8* pix){
	printf("%s{\n",__FUNCTION__);
	drawcolor(pix, 0);

	drawchip(ds, pos, pix);
	drawfoot(ds, pos, pix);
	drawpinout(ds, pos, pix);

	drawwire_pinview(pos, pix);

	writeppm(pix, 1024*4, 1024, 1024, "wire_pinview.ppm");
	printf("}%s\n",__FUNCTION__);
}
void draw_astar(design* ds, position* pos, u8* pix){
	printf("%s{\n",__FUNCTION__);
	drawcolor(pix, 0);

	drawchip(ds, pos, pix);
	//drawfoot(ds, pos, pix);
	//drawpinout(ds, pos, pix);

	//drawwire_astar(ds, pos, (u32*)pix);
	drawwire_astar_lesspinfirst(ds, pos, (u32*)pix);

	writeppm(pix, 1024*4, 1024, 1024, "wire_astar.ppm");
	printf("}%s\n",__FUNCTION__);
}
void draw(design* ds, position* pos, u8* pix){
/*
	draw_onlychip(ds, pos, pix);
	draw_onlyfoot(ds, pos, pix);
	draw_onlypinout(ds, pos, pix);
*/
	draw_chipview(ds, pos, pix);
	draw_pinview(ds, pos, pix);
	draw_astar(ds, pos, pix);
}